// ********RoostGPT********
/*
Test generated by RoostGPT for test unitTestJava using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=toString_860a850c71
ROOST_METHOD_SIG_HASH=toString_bbffdadaa2
Here are your existing test cases which we found out and are not considered for test generation:
File Path: /var/tmp/Roost/RoostGPT/unitTestJava/2923735d-fabe-435b-ac52-b6b0ad2bfdc0/source/spring-security-registration/src/test/java/com/baeldung/test/UserServiceIntegrationTest.java
Tests:
    "@Test
@Test
void givenNewUser_whenRegistered_thenCorrect() throws EmailExistsException {
    final String userEmail = UUID.randomUUID().toString();
    final UserDto userDto = createUserDto(userEmail);
    final User user = userService.registerNewUserAccount(userDto);
    assertNotNull(user);
    assertNotNull(user.getEmail());
    assertEquals(userEmail, user.getEmail());
    assertNotNull(user.getId());
}
"
    "@Test
@Test
void givenUserRegistered_whenDuplicatedRegister_thenCorrect() {
    assertThrows(UserAlreadyExistException.class, () -> {
        final String email = UUID.randomUUID().toString();
        final UserDto userDto = createUserDto(email);
        userService.registerNewUserAccount(userDto);
        userService.registerNewUserAccount(userDto);
    });
}
"
    "@Test
@Transactional
public void givenUserRegistered_whenDtoRoleAdmin_thenUserNotAdmin() {
    assertNotNull(roleRepository);
    final UserDto userDto = new UserDto();
    userDto.setEmail(UUID.randomUUID().toString());
    userDto.setPassword("SecretPassword");
    userDto.setMatchingPassword("SecretPassword");
    userDto.setFirstName("First");
    userDto.setLastName("Last");
    assertNotNull(roleRepository.findByName("ROLE_ADMIN"));
    final Long adminRoleId = roleRepository.findByName("ROLE_ADMIN").getId();
    assertNotNull(adminRoleId);
    userDto.setRole(adminRoleId.intValue());
    final User user = userService.registerNewUserAccount(userDto);
    assertFalse(user.getRoles().stream().map(Role::getId).anyMatch(ur -> ur.equals(adminRoleId)));
}
"
    "@Test
@Test
void givenUserRegistered_whenCreateToken_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
}
"
    "@Test
@Test
void givenUserRegistered_whenCreateTokenCreateDuplicate_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    userService.createVerificationTokenForUser(user, token);
}
"
    "@Test
@Test
void givenUserAndToken_whenLoadToken_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final VerificationToken verificationToken = userService.getVerificationToken(token);
    assertNotNull(verificationToken);
    assertNotNull(verificationToken.getId());
    assertNotNull(verificationToken.getUser());
    assertEquals(user, verificationToken.getUser());
    assertEquals(user.getId(), verificationToken.getUser().getId());
    assertEquals(token, verificationToken.getToken());
    assertTrue(verificationToken.getExpiryDate().toInstant().isAfter(Instant.now()));
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingUser_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    userService.deleteUser(user);
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingUserByDao_thenFKViolation() {
    assertThrows(DataIntegrityViolationException.class, () -> {
        final User user = registerUser();
        final String token = UUID.randomUUID().toString();
        userService.createVerificationTokenForUser(user, token);
        final long userId = user.getId();
        userService.getVerificationToken(token).getId();
        userRepository.deleteById(userId);
    });
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingTokenThenUser_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final long userId = user.getId();
    final long tokenId = userService.getVerificationToken(token).getId();
    tokenRepository.deleteById(tokenId);
    userRepository.deleteById(userId);
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingToken_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final long tokenId = userService.getVerificationToken(token).getId();
    tokenRepository.deleteById(tokenId);
}
"
    "@Test
@Test
void givenUserAndToken_whenNewTokenRequest_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final VerificationToken origToken = userService.getVerificationToken(token);
    final VerificationToken newToken = userService.generateNewVerificationToken(token);
    assertNotEquals(newToken.getToken(), origToken.getToken());
    assertNotEquals(newToken.getExpiryDate(), origToken.getExpiryDate());
    assertNotEquals(newToken, origToken);
}
"
    "@Test
@Test
void givenTokenValidation_whenValid_thenUserEnabled_andTokenRemoved() {
    User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final long userId = user.getId();
    final String token_status = userService.validateVerificationToken(token);
    assertEquals(token_status, UserService.TOKEN_VALID);
    user = userService.getUserByID(userId).get();
    assertTrue(user.isEnabled());
}
"
    "@Test
@Test
void givenTokenValidation_whenInvalid_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    final String invalid_token = "INVALID_" + UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    userService.getVerificationToken(token).getId();
    final String token_status = userService.validateVerificationToken(invalid_token);
    token_status.equals(UserService.TOKEN_INVALID);
}
"
    "@Test
@Test
void givenTokenValidation_whenExpired_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    user.getId();
    final VerificationToken verificationToken = userService.getVerificationToken(token);
    verificationToken.setExpiryDate(Date.from(verificationToken.getExpiryDate().toInstant().minus(2, ChronoUnit.DAYS)));
    tokenRepository.saveAndFlush(verificationToken);
    final String token_status = userService.validateVerificationToken(token);
    assertNotNull(token_status);
    token_status.equals(UserService.TOKEN_EXPIRED);
}
"
    "@Test
private User registerUser() {
    final String email = UUID.randomUUID().toString();
    final UserDto userDto = createUserDto(email);
    final User user = userService.registerNewUserAccount(userDto);
    assertNotNull(user);
    assertNotNull(user.getId());
    assertEquals(email, user.getEmail());
    return user;
}
"
File Path: /var/tmp/Roost/RoostGPT/unitTestJava/2923735d-fabe-435b-ac52-b6b0ad2bfdc0/source/spring-security-registration/src/test/java/com/baeldung/test/RegistrationControllerIntegrationTest.java
Tests:
    "@Test
@BeforeEach
public void setUp() {
    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
    User user = new User();
    user.setEmail(UUID.randomUUID().toString() + "@example.com");
    user.setPassword(UUID.randomUUID().toString());
    user.setFirstName("First");
    user.setLastName("Last");
    entityManager.persist(user);
    token = UUID.randomUUID().toString();
    VerificationToken verificationToken = new VerificationToken(token, user);
    verificationToken.setExpiryDate(Date.from(Instant.now().plus(2, ChronoUnit.DAYS)));
    entityManager.persist(verificationToken);
    /*
            flush managed entities to the database to populate identifier field
         */
    entityManager.flush();
    entityManager.clear();
}
"
File Path: /var/tmp/Roost/RoostGPT/unitTestJava/2923735d-fabe-435b-ac52-b6b0ad2bfdc0/source/spring-security-registration/src/test/java/com/baeldung/test/UserIntegrationTest.java
Tests:
    "@Test
// 
@BeforeEach
public void givenUserAndVerificationToken() throws EmailExistsException {
    User user = new User();
    user.setEmail("test@example.com");
    user.setPassword("SecretPassword");
    user.setFirstName("First");
    user.setLastName("Last");
    entityManager.persist(user);
    String token = UUID.randomUUID().toString();
    VerificationToken verificationToken = new VerificationToken(token, user);
    entityManager.persist(verificationToken);
    entityManager.flush();
    entityManager.clear();
    tokenId = verificationToken.getId();
    userId = user.getId();
}
"
File Path: /var/tmp/Roost/RoostGPT/unitTestJava/2923735d-fabe-435b-ac52-b6b0ad2bfdc0/source/spring-security-registration/src/test/java/com/baeldung/test/RegistrationPasswordLiveTest.java
Tests:
    "@Test
private int getResponseForPassword(String pass) {
    final Map<String, String> param = new HashMap<>();
    final String randomName = UUID.randomUUID().toString();
    param.put("firstName", randomName);
    param.put("lastName", "Doe");
    param.put("email", randomName + "@x.com");
    param.put("password", pass);
    param.put("matchingPassword", pass);
    final Response response = RestAssured.given().formParams(param).accept(MediaType.APPLICATION_JSON_VALUE).post(BASE_URI + "user/registration");
    return response.getStatusCode();
}
"
File Path: /var/tmp/Roost/RoostGPT/unitTestJava/2923735d-fabe-435b-ac52-b6b0ad2bfdc0/source/spring-security-registration/src/test/java/com/baeldung/test/TokenExpirationIntegrationTest.java
Tests:
    "@Test
// 
@BeforeEach
public void givenUserWithExpiredToken() {
    // we need a clear token repository
    tokenRepository.deleteAll();
    User user = new User();
    user.setEmail(UUID.randomUUID().toString() + "@example.com");
    user.setPassword(UUID.randomUUID().toString());
    user.setFirstName("First");
    user.setLastName("Last");
    entityManager.persist(user);
    String token = UUID.randomUUID().toString();
    VerificationToken verificationToken = new VerificationToken(token, user);
    verificationToken.setExpiryDate(Date.from(Instant.now().minus(2, ChronoUnit.DAYS)));
    entityManager.persist(verificationToken);
    /*
            flush managed entities to the database to populate identifier field
         */
    entityManager.flush();
    /*
            remove managed entities from the persistence context
            so that subsequent SQL queries hit the database
         */
    entityManager.clear();
    token_id = verificationToken.getId();
    user_id = user.getId();
}
""""
Scenario 1: Test the toString method with success is true
Details:  
  TestName: testToStringWithSuccessTrue
  Description: This test will verify the toString method when the success field is true. 
Execution:
  Arrange: Create a new GoogleResponse object and set success to true. 
  Act: Call the toString method on the GoogleResponse object. 
  Assert: Verify that the string returned by the toString method contains "success=true".
Validation: 
  The assertion verifies that the string representation of the GoogleResponse object correctly reflects the value of the success field. This is important to ensure that the toString method is working as expected.
Scenario 2: Test the toString method with error codes present
Details:  
  TestName: testToStringWithErrorCodes
  Description: This test will verify the toString method when there are error codes in the GoogleResponse object. 
Execution:
  Arrange: Create a new GoogleResponse object and set some error codes. 
  Act: Call the toString method on the GoogleResponse object. 
  Assert: Verify that the string returned by the toString method contains the error codes.
Validation: 
  The assertion verifies that the string representation of the GoogleResponse object correctly includes the error codes. This is important to ensure that the toString method is correctly displaying all relevant information.
Scenario 3: Test the toString method with hostname present
Details:  
  TestName: testToStringWithHostname
  Description: This test will verify the toString method when there is a hostname in the GoogleResponse object. 
Execution:
  Arrange: Create a new GoogleResponse object and set a hostname. 
  Act: Call the toString method on the GoogleResponse object. 
  Assert: Verify that the string returned by the toString method contains the hostname.
Validation: 
  The assertion verifies that the string representation of the GoogleResponse object correctly includes the hostname. This is important to ensure that the toString method is correctly displaying all relevant information.
Scenario 4: Test the toString method with score present
Details:  
  TestName: testToStringWithScore
  Description: This test will verify the toString method when there is a score in the GoogleResponse object. 
Execution:
  Arrange: Create a new GoogleResponse object and set a score. 
  Act: Call the toString method on the GoogleResponse object. 
  Assert: Verify that the string returned by the toString method contains the score.
Validation: 
  The assertion verifies that the string representation of the GoogleResponse object correctly includes the score. This is important to ensure that the toString method is correctly displaying all relevant information.
Scenario 5: Test the toString method with action present
Details:  
  TestName: testToStringWithAction
  Description: This test will verify the toString method when there is an action in the GoogleResponse object. 
Execution:
  Arrange: Create a new GoogleResponse object and set an action. 
  Act: Call the toString method on the GoogleResponse object. 
  Assert: Verify that the string returned by the toString method contains the action.
Validation: 
  The assertion verifies that the string representation of the GoogleResponse object correctly includes the action. This is important to ensure that the toString method is correctly displaying all relevant information.
"""
*/
// ********RoostGPT********
package com.baeldung.captcha;
import com.fasterxml.jackson.annotation.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.*;

@Tag("com.baeldung.captcha")
@Tag("com.baeldung.captcha.toString")
public class GoogleResponseToStringTest {
    @Test
    @Tag("valid")
    public void testToStringWithSuccessTrue() {
        GoogleResponse googleResponse = new GoogleResponse();
        googleResponse.setSuccess(true);
        assertTrue(googleResponse.toString().contains("success=true"));
    }
    @Test
    @Tag("valid")
    public void testToStringWithErrorCodes() {
        GoogleResponse googleResponse = new GoogleResponse();
        googleResponse.setErrorCodes(new ErrorCode[] {ErrorCode.InvalidResponse, ErrorCode.MissingResponse});
        assertTrue(googleResponse.toString().contains("errorCodes=[InvalidResponse, MissingResponse]"));
    }
    @Test
    @Tag("valid")
    public void testToStringWithHostname() {
        GoogleResponse googleResponse = new GoogleResponse();
        googleResponse.setHostname("test-hostname");
        assertTrue(googleResponse.toString().contains("hostname='test-hostname'"));
    }
    @Test
    @Tag("valid")
    public void testToStringWithScore() {
        GoogleResponse googleResponse = new GoogleResponse();
        googleResponse.setScore(0.9f);
        assertTrue(googleResponse.toString().contains("score=0.9"));
    }
    @Test
    @Tag("valid")
    public void testToStringWithAction() {
        GoogleResponse googleResponse = new GoogleResponse();
        googleResponse.setAction("test-action");
        assertTrue(googleResponse.toString().contains("action='test-action'"));
    }
}