// ********RoostGPT********
/*
Test generated by RoostGPT for test unittestjava1 using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=toString_860a850c71
ROOST_METHOD_SIG_HASH=toString_bbffdadaa2
Here are your existing test cases which we found out and are not considered for test generation:
File Path: /var/tmp/Roost/RoostGPT/unittestjava1/8fcd679b-678f-429b-b42f-228f95eeff76/source/spring-security-registration/src/test/java/com/baeldung/test/RegistrationControllerIntegrationTest.java
Tests:
    "@Test
@BeforeEach
public void setUp() {
    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
    User user = new User();
    user.setEmail(UUID.randomUUID().toString() + "@example.com");
    user.setPassword(UUID.randomUUID().toString());
    user.setFirstName("First");
    user.setLastName("Last");
    entityManager.persist(user);
    token = UUID.randomUUID().toString();
    VerificationToken verificationToken = new VerificationToken(token, user);
    verificationToken.setExpiryDate(Date.from(Instant.now().plus(2, ChronoUnit.DAYS)));
    entityManager.persist(verificationToken);
    /*
            flush managed entities to the database to populate identifier field
         */
    entityManager.flush();
    entityManager.clear();
}
"
File Path: /var/tmp/Roost/RoostGPT/unittestjava1/8fcd679b-678f-429b-b42f-228f95eeff76/source/spring-security-registration/src/test/java/com/baeldung/test/UserServiceIntegrationTest.java
Tests:
    "@Test
@Test
void givenNewUser_whenRegistered_thenCorrect() throws EmailExistsException {
    final String userEmail = UUID.randomUUID().toString();
    final UserDto userDto = createUserDto(userEmail);
    final User user = userService.registerNewUserAccount(userDto);
    assertNotNull(user);
    assertNotNull(user.getEmail());
    assertEquals(userEmail, user.getEmail());
    assertNotNull(user.getId());
}
"
    "@Test
@Test
void givenUserRegistered_whenDuplicatedRegister_thenCorrect() {
    assertThrows(UserAlreadyExistException.class, () -> {
        final String email = UUID.randomUUID().toString();
        final UserDto userDto = createUserDto(email);
        userService.registerNewUserAccount(userDto);
        userService.registerNewUserAccount(userDto);
    });
}
"
    "@Test
@Transactional
public void givenUserRegistered_whenDtoRoleAdmin_thenUserNotAdmin() {
    assertNotNull(roleRepository);
    final UserDto userDto = new UserDto();
    userDto.setEmail(UUID.randomUUID().toString());
    userDto.setPassword("SecretPassword");
    userDto.setMatchingPassword("SecretPassword");
    userDto.setFirstName("First");
    userDto.setLastName("Last");
    assertNotNull(roleRepository.findByName("ROLE_ADMIN"));
    final Long adminRoleId = roleRepository.findByName("ROLE_ADMIN").getId();
    assertNotNull(adminRoleId);
    userDto.setRole(adminRoleId.intValue());
    final User user = userService.registerNewUserAccount(userDto);
    assertFalse(user.getRoles().stream().map(Role::getId).anyMatch(ur -> ur.equals(adminRoleId)));
}
"
    "@Test
@Test
void givenUserRegistered_whenCreateToken_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
}
"
    "@Test
@Test
void givenUserRegistered_whenCreateTokenCreateDuplicate_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    userService.createVerificationTokenForUser(user, token);
}
"
    "@Test
@Test
void givenUserAndToken_whenLoadToken_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final VerificationToken verificationToken = userService.getVerificationToken(token);
    assertNotNull(verificationToken);
    assertNotNull(verificationToken.getId());
    assertNotNull(verificationToken.getUser());
    assertEquals(user, verificationToken.getUser());
    assertEquals(user.getId(), verificationToken.getUser().getId());
    assertEquals(token, verificationToken.getToken());
    assertTrue(verificationToken.getExpiryDate().toInstant().isAfter(Instant.now()));
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingUser_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    userService.deleteUser(user);
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingUserByDao_thenFKViolation() {
    assertThrows(DataIntegrityViolationException.class, () -> {
        final User user = registerUser();
        final String token = UUID.randomUUID().toString();
        userService.createVerificationTokenForUser(user, token);
        final long userId = user.getId();
        userService.getVerificationToken(token).getId();
        userRepository.deleteById(userId);
    });
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingTokenThenUser_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final long userId = user.getId();
    final long tokenId = userService.getVerificationToken(token).getId();
    tokenRepository.deleteById(tokenId);
    userRepository.deleteById(userId);
}
"
    "@Test
@Test
void givenUserAndToken_whenRemovingToken_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final long tokenId = userService.getVerificationToken(token).getId();
    tokenRepository.deleteById(tokenId);
}
"
    "@Test
@Test
void givenUserAndToken_whenNewTokenRequest_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final VerificationToken origToken = userService.getVerificationToken(token);
    final VerificationToken newToken = userService.generateNewVerificationToken(token);
    assertNotEquals(newToken.getToken(), origToken.getToken());
    assertNotEquals(newToken.getExpiryDate(), origToken.getExpiryDate());
    assertNotEquals(newToken, origToken);
}
"
    "@Test
@Test
void givenTokenValidation_whenValid_thenUserEnabled_andTokenRemoved() {
    User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    final long userId = user.getId();
    final String token_status = userService.validateVerificationToken(token);
    assertEquals(token_status, UserService.TOKEN_VALID);
    user = userService.getUserByID(userId).get();
    assertTrue(user.isEnabled());
}
"
    "@Test
@Test
void givenTokenValidation_whenInvalid_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    final String invalid_token = "INVALID_" + UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    userService.getVerificationToken(token).getId();
    final String token_status = userService.validateVerificationToken(invalid_token);
    token_status.equals(UserService.TOKEN_INVALID);
}
"
    "@Test
@Test
void givenTokenValidation_whenExpired_thenCorrect() {
    final User user = registerUser();
    final String token = UUID.randomUUID().toString();
    userService.createVerificationTokenForUser(user, token);
    user.getId();
    final VerificationToken verificationToken = userService.getVerificationToken(token);
    verificationToken.setExpiryDate(Date.from(verificationToken.getExpiryDate().toInstant().minus(2, ChronoUnit.DAYS)));
    tokenRepository.saveAndFlush(verificationToken);
    final String token_status = userService.validateVerificationToken(token);
    assertNotNull(token_status);
    token_status.equals(UserService.TOKEN_EXPIRED);
}
"
    "@Test
private User registerUser() {
    final String email = UUID.randomUUID().toString();
    final UserDto userDto = createUserDto(email);
    final User user = userService.registerNewUserAccount(userDto);
    assertNotNull(user);
    assertNotNull(user.getId());
    assertEquals(email, user.getEmail());
    return user;
}
"
File Path: /var/tmp/Roost/RoostGPT/unittestjava1/8fcd679b-678f-429b-b42f-228f95eeff76/source/spring-security-registration/src/test/java/com/baeldung/test/RegistrationPasswordLiveTest.java
Tests:
    "@Test
private int getResponseForPassword(String pass) {
    final Map<String, String> param = new HashMap<>();
    final String randomName = UUID.randomUUID().toString();
    param.put("firstName", randomName);
    param.put("lastName", "Doe");
    param.put("email", randomName + "@x.com");
    param.put("password", pass);
    param.put("matchingPassword", pass);
    final Response response = RestAssured.given().formParams(param).accept(MediaType.APPLICATION_JSON_VALUE).post(BASE_URI + "user/registration");
    return response.getStatusCode();
}
"
File Path: /var/tmp/Roost/RoostGPT/unittestjava1/8fcd679b-678f-429b-b42f-228f95eeff76/source/spring-security-registration/src/test/java/com/baeldung/test/UserIntegrationTest.java
Tests:
    "@Test
// 
@BeforeEach
public void givenUserAndVerificationToken() throws EmailExistsException {
    User user = new User();
    user.setEmail("test@example.com");
    user.setPassword("SecretPassword");
    user.setFirstName("First");
    user.setLastName("Last");
    entityManager.persist(user);
    String token = UUID.randomUUID().toString();
    VerificationToken verificationToken = new VerificationToken(token, user);
    entityManager.persist(verificationToken);
    entityManager.flush();
    entityManager.clear();
    tokenId = verificationToken.getId();
    userId = user.getId();
}
"
File Path: /var/tmp/Roost/RoostGPT/unittestjava1/8fcd679b-678f-429b-b42f-228f95eeff76/source/spring-security-registration/src/test/java/com/baeldung/test/TokenExpirationIntegrationTest.java
Tests:
    "@Test
// 
@BeforeEach
public void givenUserWithExpiredToken() {
    // we need a clear token repository
    tokenRepository.deleteAll();
    User user = new User();
    user.setEmail(UUID.randomUUID().toString() + "@example.com");
    user.setPassword(UUID.randomUUID().toString());
    user.setFirstName("First");
    user.setLastName("Last");
    entityManager.persist(user);
    String token = UUID.randomUUID().toString();
    VerificationToken verificationToken = new VerificationToken(token, user);
    verificationToken.setExpiryDate(Date.from(Instant.now().minus(2, ChronoUnit.DAYS)));
    entityManager.persist(verificationToken);
    /*
            flush managed entities to the database to populate identifier field
         */
    entityManager.flush();
    /*
            remove managed entities from the persistence context
            so that subsequent SQL queries hit the database
         */
    entityManager.clear();
    token_id = verificationToken.getId();
    user_id = user.getId();
}
"Scenario 1: Testing the toString method for a valid GoogleResponse object
Details:  
  TestName: testToStringForValidObject
  Description: This test will check if the toString method correctly formats the string representation of a valid GoogleResponse object. 
Execution:
  Arrange: Create a GoogleResponse object and set all its fields with valid data.
  Act: Invoke the toString method on the GoogleResponse object.
  Assert: Compare the returned string with the expected string.
Validation: 
  The assertion verifies that the toString method correctly formats the string representation of the GoogleResponse object. This test is important to ensure that the toString method is working as expected, as it is often used for logging and debugging purposes.
Scenario 2: Testing the toString method for an empty GoogleResponse object
Details:  
  TestName: testToStringForEmptyObject
  Description: This test will check if the toString method correctly formats the string representation of an empty GoogleResponse object.
Execution:
  Arrange: Create an empty GoogleResponse object.
  Act: Invoke the toString method on the empty GoogleResponse object.
  Assert: Compare the returned string with the expected string.
Validation: 
  The assertion verifies that the toString method correctly formats the string representation of an empty GoogleResponse object. This test is important to ensure that the toString method can handle objects with null or unset fields.
Scenario 3: Testing the toString method for a GoogleResponse object with null error codes
Details:  
  TestName: testToStringForNullErrorCodes
  Description: This test will check if the toString method correctly formats the string representation of a GoogleResponse object with null error codes.
Execution:
  Arrange: Create a GoogleResponse object and set all its fields with valid data, except for error codes, which should be set to null.
  Act: Invoke the toString method on the GoogleResponse object.
  Assert: Compare the returned string with the expected string.
Validation: 
  The assertion verifies that the toString method correctly formats the string representation of a GoogleResponse object with null error codes. This test is important to ensure that the toString method can handle objects with null fields.
Scenario 4: Testing the toString method for a GoogleResponse object with multiple error codes
Details:  
  TestName: testToStringForMultipleErrorCodes
  Description: This test will check if the toString method correctly formats the string representation of a GoogleResponse object with multiple error codes.
Execution:
  Arrange: Create a GoogleResponse object and set all its fields with valid data, and set error codes with multiple values.
  Act: Invoke the toString method on the GoogleResponse object.
  Assert: Compare the returned string with the expected string.
Validation: 
  The assertion verifies that the toString method correctly formats the string representation of a GoogleResponse object with multiple error codes. This test is important to ensure that the toString method can handle objects with array fields containing multiple values.
*/
// ********RoostGPT********
package com.baeldung.captcha;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import com.fasterxml.jackson.annotation.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.*;

@Tag("com.baeldung.captcha")
@Tag("com.baeldung.captcha.toString")
public class GoogleResponseToStringTest {
    @Test
    @Tag("valid")
    public void testToStringForValidObject() {
        GoogleResponse response = new GoogleResponse();
        response.setSuccess(true);
        response.setChallengeTimeStamp("2021-06-01T00:00:00Z");
        response.setHostname("test.com");
        response.setScore(0.9f);
        response.setAction("testAction");
        response.setErrorCodes(new ErrorCode[] { ErrorCode.InvalidResponse });
        String expected = "GoogleResponse{success=true, challengeTs='2021-06-01T00:00:00Z', hostname='test.com', score='0.9', action='testAction', errorCodes=[InvalidResponse]}";
        String actual = response.toString();
        assertEquals(expected, actual);
    }
    @Test
    @Tag("valid")
    public void testToStringForEmptyObject() {
        GoogleResponse response = new GoogleResponse();
        String expected = "GoogleResponse{success=false, challengeTs='null', hostname='null', score='0.0', action='null', errorCodes=null}";
        String actual = response.toString();
        assertEquals(expected, actual);
    }
    @Test
    @Tag("valid")
    public void testToStringForNullErrorCodes() {
        GoogleResponse response = new GoogleResponse();
        response.setSuccess(true);
        response.setChallengeTimeStamp("2021-06-01T00:00:00Z");
        response.setHostname("test.com");
        response.setScore(0.9f);
        response.setAction("testAction");
        response.setErrorCodes(null);
        String expected = "GoogleResponse{success=true, challengeTs='2021-06-01T00:00:00Z', hostname='test.com', score='0.9', action='testAction', errorCodes=null}";
        String actual = response.toString();
        assertEquals(expected, actual);
    }
    @Test
    @Tag("valid")
    public void testToStringForMultipleErrorCodes() {
        GoogleResponse response = new GoogleResponse();
        response.setSuccess(true);
        response.setChallengeTimeStamp("2021-06-01T00:00:00Z");
        response.setHostname("test.com");
        response.setScore(0.9f);
        response.setAction("testAction");
        response.setErrorCodes(new ErrorCode[] { ErrorCode.InvalidResponse, ErrorCode.MissingResponse, ErrorCode.BadRequest });
        String expected = "GoogleResponse{success=true, challengeTs='2021-06-01T00:00:00Z', hostname='test.com', score='0.9', action='testAction', errorCodes=[InvalidResponse, MissingResponse, BadRequest]}";
        String actual = response.toString();
        assertEquals(expected, actual);
    }
}